# Distributed SSoT Architecture

**Problem**: APML grew too large (60k+ lines) to maintain as single SSoT
**Solution**: Distributed SSoT across multiple layers with clear authority hierarchy

---

## Three-Tier SSoT Hierarchy

### TIER 1: Source SSoT (Version Controlled)
**Authority**: What developers edit
**Location**: Git repository
**Format**: Human-readable files

```
ssi-course-production.apml           # Original APML (still used for some data)
.apml-registry.json                  # Compiled from APML (generated)
docs/phase_intelligence/
  ‚îú‚îÄ‚îÄ phase_1_translation.md         # Phase 1 methodology
  ‚îú‚îÄ‚îÄ phase_3_extraction.md          # Phase 3 methodology (v2.0)
  ‚îú‚îÄ‚îÄ phase_5_baskets.md             # Phase 5 methodology
  ‚îî‚îÄ‚îÄ README.md                      # Module catalog
schemas/
  ‚îú‚îÄ‚îÄ phase1-seed_pairs.json         # Data structure schemas
  ‚îú‚îÄ‚îÄ phase3-lego_pairs.json
  ‚îî‚îÄ‚îÄ phase5-lego_baskets.json
```

**What's Here**:
- ‚úÖ Phase methodology (phase intelligence modules)
- ‚úÖ Data structure schemas (JSON schemas)
- ‚úÖ Variable registry (batch sizes, paths)
- ‚úÖ System configuration

**NOT Here**:
- ‚ùå Course data (that's in VFS)
- ‚ùå Runtime state (that's in dashboard)

---

### TIER 2: Compiled SSoT (Generated)
**Authority**: Build artifact from Tier 1
**Location**: `.apml-registry.json`
**Format**: Machine-readable JSON

**Generated by**: `node scripts/compile-apml-registry.cjs`

**Contents**:
```json
{
  "version": "7.7.0",
  "generated_at": "2025-10-23T11:22:49.684Z",

  "variable_registry": {
    "TOTAL_SEEDS": 668,
    "BATCH_SIZES": {...},
    "VFS_PATHS": {...}
  },

  "phase_intelligence": {
    "modules": {
      "phase_3": {
        "source_file": "docs/phase_intelligence/phase_3_extraction.md",
        "dashboard_endpoint": "/api/phase-intelligence/3",
        "current_version": "2.0"
      }
    }
  },

  "PHASE_PROMPTS": {
    "deprecation_notice": "Use phase_intelligence modules instead",
    "PHASE_1": {...},  // Legacy prompts (backwards compatibility)
    "PHASE_3": {...}
  }
}
```

**Purpose**:
- Pointer registry (tells dashboard where to find things)
- Backwards compatibility (old PHASE_PROMPTS)
- Version tracking
- Fast lookup without parsing APML

---

### TIER 3: Runtime SSoT (Published)
**Authority**: What agents ACTUALLY read during execution
**Location**: Dashboard API
**Format**: REST API responses

**Endpoints**:
```
GET /api/phase-intelligence/:phase     # Fetch current methodology
GET /api/prompts/:phase                # Legacy fallback
GET /api/courses/:code                 # Course data
```

**Storage**:
- In-memory (loaded from Tier 1/2)
- OR Database (for published versions with history)

**Example Flow**:
```
Agent triggered ‚Üí GET /api/phase-intelligence/3
                ‚Üí Dashboard reads docs/phase_intelligence/phase_3_extraction.md
                ‚Üí Returns v2.0 methodology
                ‚Üí Agent applies rules
```

---

## What Is SSoT for What?

### Phase Methodology SSoT
**Source**: `docs/phase_intelligence/phase_X_*.md`
**Compiled**: `.apml-registry.json` ‚Üí `phase_intelligence.modules`
**Runtime**: Dashboard API `/api/phase-intelligence/:phase`

**Authority Chain**: Local file ‚Üí Dashboard API ‚Üí Agent

---

### Data Structure SSoT
**Source**: `schemas/phase*-*.json`
**Compiled**: `.apml-registry.json` ‚Üí `variable_registry.SCHEMAS`
**Runtime**: Dashboard API `/api/schemas/:phase`

**Authority Chain**: Schema file ‚Üí Validation ‚Üí Course data

---

### Variable Configuration SSoT
**Source**: `ssi-course-production.apml` (VARIABLES section)
**Compiled**: `.apml-registry.json` ‚Üí `variable_registry`
**Runtime**: Loaded into automation server memory

**Authority Chain**: APML ‚Üí Registry ‚Üí Server config

---

### Course Data SSoT
**Source**: N/A (dynamically generated)
**Storage**: `vfs/courses/{code}/` (local filesystem)
**Runtime**: Dashboard API `/api/courses/:code/vfs/:filename`

**Authority Chain**: Generator agent ‚Üí VFS ‚Üí Dashboard serves it

---

## Why Distributed?

### Problem 1: Size
- APML was 60k+ lines
- Can't atomically edit
- Risk of conflicts

**Solution**: Split into modular files
- Each phase intelligence = separate file
- Easy to edit one at a time

---

### Problem 2: Versions
- Need to track methodology evolution
- Need history per phase
- Need diff between versions

**Solution**: Git per module
- Each module has own git history
- Can compare versions
- Can rollback if needed

---

### Problem 3: Runtime Access
- Agents need latest methodology
- Can't read local files from Vercel
- Need API access

**Solution**: Dashboard serves as runtime SSoT
- Published via API
- Always latest version
- Agents read from dashboard

---

### Problem 4: Backwards Compatibility
- Can't break existing agents immediately
- Need gradual migration
- Need fallbacks

**Solution**: Layered approach
- New: Phase intelligence modules
- Old: PHASE_PROMPTS in registry
- Fallback: Dashboard serves both

---

## SSoT Update Flow

### Scenario 1: Update Phase Methodology

```
1. Developer discovers new intelligence
   ‚Üì
2. Update: docs/phase_intelligence/phase_3_extraction.md
   (Bump version: 2.0 ‚Üí 2.1)
   ‚Üì
3. Git commit: "Add composability scoring examples"
   ‚Üì
4. Update registry reference:
   .apml-registry.json ‚Üí phase_intelligence.modules.phase_3.current_version = "2.1"
   ‚Üì
5. Publish to dashboard:
   PUT /api/phase-intelligence/3
   Body: {content, version: "2.1"}
   ‚Üì
6. Dashboard serves v2.1
   ‚Üì
7. Agents read v2.1 from dashboard
```

---

### Scenario 2: Update Variable Configuration

```
1. Developer changes batch size
   ‚Üì
2. Update: ssi-course-production.apml
   BATCH_SIZES.PHASE_3 = 20 ‚Üí 30
   ‚Üì
3. Regenerate registry:
   node scripts/compile-apml-registry.cjs
   ‚Üì
4. Registry updated:
   .apml-registry.json ‚Üí variable_registry.BATCH_SIZES.PHASE_3 = 30
   ‚Üì
5. Restart automation server:
   Loads new registry into memory
   ‚Üì
6. Agents use new batch size
```

---

### Scenario 3: Update Data Schema

```
1. Developer adds new field to lego_pairs
   ‚Üì
2. Update: schemas/phase3-lego_pairs.json
   Add "composability_score" field
   ‚Üì
3. Git commit: "Add composability score to lego_pairs"
   ‚Üì
4. Validation updated automatically
   (AJV loads schema from file)
   ‚Üì
5. Future course generations validated against new schema
```

---

## SSoT Authority Matrix

| Component | Source SSoT | Compiled SSoT | Runtime SSoT | Used By |
|-----------|-------------|---------------|--------------|---------|
| Phase Methodology | `phase_X_*.md` | Registry pointer | Dashboard API | Agents |
| Data Schemas | `schemas/*.json` | Registry pointer | Validator | Generators |
| Variables | `APML` | Registry | Server memory | Server |
| Legacy Prompts | `APML` | Registry | Server memory | Old agents |
| Course Data | N/A | N/A | VFS | Dashboard UI |

---

## Current State (v7.7.0)

### ‚úÖ Already Distributed:
- Data schemas ‚Üí `schemas/` directory
- Phase intelligence ‚Üí `docs/phase_intelligence/`
- Course data ‚Üí `vfs/courses/`

### ‚ö†Ô∏è Still in APML:
- Variable registry (BATCH_SIZES, VFS_PATHS)
- Legacy PHASE_PROMPTS (backwards compatibility)
- System configuration

### üîÑ Hybrid State:
- Registry references phase intelligence modules
- Dashboard can serve from both sources
- Agents can read from either (with fallback)

---

## APML Registry v7.7.0 Needs

The registry needs a **new section** to document this architecture:

```json
{
  "version": "7.7.0",
  "architecture": {
    "tier1_source": {
      "apml": "ssi-course-production.apml",
      "phase_intelligence": "docs/phase_intelligence/",
      "schemas": "schemas/",
      "purpose": "Version controlled source of truth"
    },
    "tier2_compiled": {
      "registry": ".apml-registry.json",
      "generated_by": "scripts/compile-apml-registry.cjs",
      "purpose": "Pointer index and backwards compatibility"
    },
    "tier3_runtime": {
      "dashboard_api": "http://localhost:3456/api/",
      "endpoints": {
        "phase_intelligence": "/api/phase-intelligence/:phase",
        "prompts_legacy": "/api/prompts/:phase",
        "courses": "/api/courses/:code",
        "schemas": "/api/schemas/:phase"
      },
      "purpose": "Runtime SSoT that agents read"
    }
  },

  "phase_intelligence": {
    "status": "ACTIVE - Primary methodology source",
    "modules_directory": "docs/phase_intelligence/",
    "modules": {
      "phase_1": {
        "source_file": "docs/phase_intelligence/phase_1_translation.md",
        "dashboard_endpoint": "/api/phase-intelligence/1",
        "current_version": "1.0",
        "status": "pending_creation"
      },
      "phase_3": {
        "source_file": "docs/phase_intelligence/phase_3_extraction.md",
        "dashboard_endpoint": "/api/phase-intelligence/3",
        "current_version": "2.0",
        "status": "active",
        "last_updated": "2025-10-23T11:30:00Z"
      }
    }
  },

  "variable_registry": {...existing...},

  "PHASE_PROMPTS": {
    "status": "DEPRECATED - Use phase_intelligence instead",
    "fallback_until": "2025-11-23",
    ...existing prompts for backwards compatibility...
  }
}
```

---

## Key Insight

**We don't have ONE SSoT - we have a THREE-TIER SSoT HIERARCHY:**

1. **Source Tier** (Developers edit) - Local files
2. **Compiled Tier** (Build artifact) - Registry
3. **Runtime Tier** (Agents read) - Dashboard API

Each tier has different authority:
- **Source** = Canonical truth (version controlled)
- **Compiled** = Indexed/optimized (generated)
- **Runtime** = Current published (what's being used)

**The registry's job**: Be the **pointer index** that connects all three tiers.

---

**Next**: Update `.apml-registry.json` to reflect this architecture and point to phase intelligence modules.
